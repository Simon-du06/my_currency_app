"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectBuildToCompareAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const builds_1 = require("../../commandUtils/builds");
const flags_1 = require("../../commandUtils/flags");
const generated_1 = require("../../graphql/generated");
const FingerprintMutation_1 = require("../../graphql/mutations/FingerprintMutation");
const BuildQuery_1 = require("../../graphql/queries/BuildQuery");
const FingerprintQuery_1 = require("../../graphql/queries/FingerprintQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const maybeUploadFingerprintAsync_1 = require("../../project/maybeUploadFingerprintAsync");
const projectUtils_1 = require("../../project/projectUtils");
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const fingerprintCli_1 = require("../../utils/fingerprintCli");
const fingerprintDiff_1 = require("../../utils/fingerprintDiff");
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
var FingerprintOriginType;
(function (FingerprintOriginType) {
    FingerprintOriginType["Build"] = "build";
    FingerprintOriginType["Hash"] = "hash";
    FingerprintOriginType["Project"] = "project";
})(FingerprintOriginType || (FingerprintOriginType = {}));
class FingerprintCompare extends EasCommand_1.default {
    static description = 'compare fingerprints of the current project, builds and updates';
    static strict = false;
    static examples = [
        '$ eas fingerprint:compare \t # Compare fingerprints in interactive mode',
        '$ eas fingerprint:compare c71a7d475aa6f75291bc93cd74aef395c3c94eee \t # Compare fingerprint against local directory',
        '$ eas fingerprint:compare c71a7d475aa6f75291bc93cd74aef395c3c94eee f0d6a916e73f401d428e6e006e07b12453317ba2 \t # Compare provided fingerprints',
        '$ eas fingerprint:compare --build-id 82bc6456-611a-48cb-8db4-5f9eb2ca1003 \t # Compare fingerprint from build against local directory',
    ];
    static args = [
        {
            name: 'hash1',
            description: "If provided alone, HASH1 is compared against the current project's fingerprint.",
            required: false,
        },
        {
            name: 'hash2',
            description: 'If two hashes are provided, HASH1 is compared against HASH2.',
            required: false,
        },
    ];
    static flags = {
        'build-id': core_1.Flags.string({
            aliases: ['buildId'],
            description: 'Compare the fingerprint with the build with the specified ID',
        }),
        ...flags_1.EasNonInteractiveAndJsonFlags,
    };
    static contextDefinition = {
        ...this.ContextOptions.ProjectId,
        ...this.ContextOptions.ProjectConfig,
        ...this.ContextOptions.LoggedIn,
        ...this.ContextOptions.Vcs,
    };
    async runAsync() {
        const { args, flags } = await this.parse(FingerprintCompare);
        const { hash1, hash2 } = args;
        const { json, 'non-interactive': nonInteractive, 'build-id': buildId } = flags;
        const sanitizedFlagsAndArgs = { json, nonInteractive, buildId, hash1, hash2 };
        const { projectId, privateProjectConfig: { projectDir }, loggedIn: { graphqlClient }, vcsClient, } = await this.getContextAsync(FingerprintCompare, {
            nonInteractive,
            withServerSideEnvironment: null,
        });
        if (json) {
            (0, json_1.enableJsonOutput)();
        }
        const firstFingerprintInfo = await getFirstFingerprintInfoAsync(graphqlClient, projectId, sanitizedFlagsAndArgs);
        const { fingerprint: firstFingerprint, origin: firstFingerprintOrigin } = firstFingerprintInfo;
        const secondFingerprintInfo = await getSecondFingerprintInfoAsync(graphqlClient, projectDir, projectId, vcsClient, firstFingerprintInfo, sanitizedFlagsAndArgs);
        const { fingerprint: secondFingerprint, origin: secondFingerprintOrigin } = secondFingerprintInfo;
        if (json) {
            (0, json_1.printJsonOnlyOutput)({ fingerprint1: firstFingerprint, fingerprint2: secondFingerprint });
            return;
        }
        if (firstFingerprint.hash === secondFingerprint.hash) {
            log_1.default.log(`✅ ${capitalizeFirstLetter(prettyPrintFingerprint(firstFingerprint, firstFingerprintOrigin))} matches fingerprint from ${prettyPrintFingerprint(secondFingerprint, secondFingerprintOrigin)}`);
            return;
        }
        else {
            log_1.default.log(`🔄 ${capitalizeFirstLetter(prettyPrintFingerprint(firstFingerprint, firstFingerprintOrigin))} differs from ${prettyPrintFingerprint(secondFingerprint, secondFingerprintOrigin)}`);
        }
        const fingerprintDiffs = (0, fingerprintCli_1.diffFingerprint)(projectDir, firstFingerprint, secondFingerprint);
        if (!fingerprintDiffs) {
            log_1.default.error('Fingerprint diffs can only be computed for projects with SDK 52 or higher');
            return;
        }
        const filePathDiffs = fingerprintDiffs.filter(diff => {
            let sourceType;
            if (diff.op === 'added') {
                sourceType = diff.addedSource.type;
            }
            else if (diff.op === 'removed') {
                sourceType = diff.removedSource.type;
            }
            else if (diff.op === 'changed') {
                sourceType = diff.beforeSource.type;
            }
            return sourceType === 'dir' || sourceType === 'file';
        });
        if (filePathDiffs.length > 0) {
            log_1.default.newLine();
            log_1.default.log('📁 Paths with native dependencies:');
        }
        const fields = [];
        for (const diff of filePathDiffs) {
            const field = getDiffFilePathFields(diff);
            if (!field) {
                throw new Error(`Unsupported diff: ${JSON.stringify(diff)}`);
            }
            fields.push(field);
        }
        log_1.default.log((0, formatFields_1.default)(fields, {
            labelFormat: label => `    ${chalk_1.default.dim(label)}:`,
        }));
        const contentDiffs = fingerprintDiffs.filter(diff => {
            let sourceType;
            if (diff.op === 'added') {
                sourceType = diff.addedSource.type;
            }
            else if (diff.op === 'removed') {
                sourceType = diff.removedSource.type;
            }
            else if (diff.op === 'changed') {
                sourceType = diff.beforeSource.type;
            }
            return sourceType === 'contents';
        });
        for (const diff of contentDiffs) {
            printContentDiff(diff);
        }
    }
}
exports.default = FingerprintCompare;
function prettyPrintFingerprint(fingerprint, origin) {
    if (origin.type === FingerprintOriginType.Hash) {
        return `fingerprint ${fingerprint.hash} from hash`;
    }
    return `fingerprint ${fingerprint.hash} from ${origin.type}`;
}
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
async function getFirstFingerprintInfoAsync(graphqlClient, projectId, { buildId: buildIdFromArg, hash1, nonInteractive }) {
    if (hash1) {
        const fingerprintFragment = await getFingerprintFragmentFromHashAsync(graphqlClient, projectId, hash1);
        const fingerprint = await getFingerprintFromFingerprintFragmentAsync(fingerprintFragment);
        let platforms;
        const fingerprintBuilds = fingerprintFragment.builds?.edges.map(edge => edge.node) ?? [];
        const fingerprintUpdates = fingerprintFragment.updates?.edges.map(edge => edge.node) ?? [];
        if (fingerprintBuilds.length > 0) {
            platforms = [fingerprintBuilds[0].platform];
        }
        else if (fingerprintUpdates.length > 0) {
            platforms = [stringToAppPlatform(fingerprintUpdates[0].platform)];
        }
        return {
            fingerprint,
            platforms,
            origin: {
                type: FingerprintOriginType.Hash,
            },
        };
    }
    let buildId = buildIdFromArg ?? null;
    if (!buildId) {
        if (nonInteractive) {
            throw new Error('Build ID must be provided in non-interactive mode');
        }
        const displayName = await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId);
        buildId = await selectBuildToCompareAsync(graphqlClient, projectId, displayName, {
            filters: { hasFingerprint: true },
        });
        if (!buildId) {
            throw new Error('Must select build with fingerprint for comparison.');
        }
    }
    log_1.default.log(`Comparing fingerprints of the current project and build ${buildId}…`);
    const buildWithFingerprint = await BuildQuery_1.BuildQuery.withFingerprintByIdAsync(graphqlClient, buildId);
    if (!buildWithFingerprint.fingerprint) {
        throw new Error(`Fingerprint for build ${buildId} was not computed.`);
    }
    else if (!buildWithFingerprint.fingerprint.debugInfoUrl) {
        throw new Error(`Fingerprint source for build ${buildId} was not computed.`);
    }
    return {
        fingerprint: await getFingerprintFromFingerprintFragmentAsync(buildWithFingerprint.fingerprint),
        platforms: [buildWithFingerprint.platform],
        origin: {
            type: FingerprintOriginType.Build,
            build: buildWithFingerprint,
        },
    };
}
async function getSecondFingerprintInfoAsync(graphqlClient, projectDir, projectId, vcsClient, firstFingerprintInfo, { hash2 }) {
    if (hash2) {
        const fingerprintFragment = await getFingerprintFragmentFromHashAsync(graphqlClient, projectId, hash2);
        if (!fingerprintFragment) {
            throw new Error(`Fingerprint with hash ${hash2} was not uploaded.`);
        }
        return {
            fingerprint: await getFingerprintFromFingerprintFragmentAsync(fingerprintFragment),
            origin: { type: FingerprintOriginType.Hash },
        };
    }
    const firstFingerprintPlatforms = firstFingerprintInfo.platforms;
    if (!firstFingerprintPlatforms) {
        throw new Error(`Cannot compare the local directory against the provided fingerprint hash "${firstFingerprintInfo.fingerprint.hash}" because the associated platform could not be determined. Ensure the fingerprint is linked to a build or update to identify the platform.`);
    }
    const workflows = await (0, workflow_1.resolveWorkflowPerPlatformAsync)(projectDir, vcsClient);
    const optionsFromWorkflow = getFingerprintOptionsFromWorkflow(firstFingerprintPlatforms, workflows);
    const projectFingerprint = await (0, fingerprintCli_1.createFingerprintAsync)(projectDir, {
        ...optionsFromWorkflow,
        platforms: firstFingerprintPlatforms.map(appPlatformToString),
        debug: true,
        env: undefined,
    });
    if (!projectFingerprint) {
        throw new Error('Project fingerprints can only be computed for projects with SDK 52 or higher');
    }
    const uploadedFingerprint = await (0, maybeUploadFingerprintAsync_1.maybeUploadFingerprintAsync)({
        hash: projectFingerprint.hash,
        fingerprint: {
            fingerprintSources: projectFingerprint.sources,
            isDebugFingerprintSource: log_1.default.isDebug,
        },
        graphqlClient,
    });
    await FingerprintMutation_1.FingerprintMutation.createFingerprintAsync(graphqlClient, projectId, {
        hash: uploadedFingerprint.hash,
        source: uploadedFingerprint.fingerprintSource,
    });
    return { fingerprint: projectFingerprint, origin: { type: FingerprintOriginType.Project } };
}
async function getFingerprintFragmentFromHashAsync(graphqlClient, projectId, hash) {
    const fingerprint = await FingerprintQuery_1.FingerprintQuery.byHashAsync(graphqlClient, {
        appId: projectId,
        hash,
    });
    if (!fingerprint) {
        const displayName = await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId);
        throw new Error(`Fingerprint with hash ${hash} was not uploaded for ${displayName}.`);
    }
    return fingerprint;
}
async function getFingerprintFromFingerprintFragmentAsync(fingerprintFragment) {
    const fingerprintDebugUrl = fingerprintFragment.debugInfoUrl;
    if (!fingerprintDebugUrl) {
        throw new Error(`The source for fingerprint hash ${fingerprintFragment.hash} was not computed.`);
    }
    const fingerprintResponse = await fetch(fingerprintDebugUrl);
    return (await fingerprintResponse.json());
}
function getFingerprintOptionsFromWorkflow(platforms, workflowsByPlatform) {
    if (platforms.length === 0) {
        throw new Error('Could not determine platform from fingerprint sources');
    }
    // Single platform case
    if (platforms.length === 1) {
        const platform = platforms[0];
        return { workflow: workflowsByPlatform[appPlatformToPlatform(platform)] };
    }
    // Multiple platforms case
    const workflows = platforms.map(platform => workflowsByPlatform[appPlatformToPlatform(platform)]);
    // If all workflows are the same, return the common workflow
    const [firstWorkflow, ...restWorkflows] = workflows;
    if (restWorkflows.every(workflow => workflow === firstWorkflow)) {
        return { workflow: firstWorkflow };
    }
    // Generate ignorePaths for mixed workflows
    const ignorePaths = platforms
        .filter(platform => workflowsByPlatform[appPlatformToPlatform(platform)] === eas_build_job_1.Workflow.MANAGED)
        .map(platform => `${appPlatformToString(platform)}/**/*`);
    return { ignorePaths };
}
function printContentDiff(diff) {
    if (diff.op === 'added') {
        const sourceType = diff.addedSource.type;
        if (sourceType === 'contents') {
            printContentSource({
                op: diff.op,
                sourceType,
                contentsId: diff.addedSource.id,
                contentsAfter: diff.addedSource.contents,
            });
        }
    }
    else if (diff.op === 'removed') {
        const sourceType = diff.removedSource.type;
        if (sourceType === 'contents') {
            printContentSource({
                op: diff.op,
                sourceType,
                contentsId: diff.removedSource.id,
                contentsBefore: diff.removedSource.contents,
            });
        }
    }
    else if (diff.op === 'changed') {
        const sourceType = diff.beforeSource.type;
        if (sourceType === 'contents') {
            if (diff.afterSource.type !== 'contents') {
                throw new Error(`Changed fingerprint source types must be the same, received ${diff.beforeSource.type}, ${diff.afterSource.type}`);
            }
            printContentSource({
                op: diff.op,
                sourceType: diff.beforeSource.type, // before and after source types should be the same
                contentsId: diff.beforeSource.id, // before and after content ids should be the same
                contentsBefore: diff.beforeSource.contents,
                contentsAfter: diff.afterSource.contents,
            });
        }
    }
}
function getDiffFilePathFields(diff) {
    if (diff.op === 'added') {
        const sourceType = diff.addedSource.type;
        if (sourceType !== 'contents') {
            return getFilePathSourceFields({
                op: diff.op,
                sourceType,
                filePath: diff.addedSource.filePath,
            });
        }
    }
    else if (diff.op === 'removed') {
        const sourceType = diff.removedSource.type;
        if (sourceType !== 'contents') {
            return getFilePathSourceFields({
                op: diff.op,
                sourceType,
                filePath: diff.removedSource.filePath,
            });
        }
    }
    else if (diff.op === 'changed') {
        const sourceType = diff.beforeSource.type;
        if (sourceType !== 'contents') {
            return getFilePathSourceFields({
                op: diff.op,
                sourceType: diff.beforeSource.type, // before and after source types should be the same
                filePath: diff.beforeSource.filePath, // before and after filePaths should be the same
            });
        }
    }
    return null;
}
function getFilePathSourceFields({ op, sourceType, filePath, }) {
    if (sourceType === 'dir') {
        if (op === 'added') {
            return { label: 'new directory', value: filePath };
        }
        else if (op === 'removed') {
            return { label: 'removed directory', value: filePath };
        }
        else if (op === 'changed') {
            return { label: 'modified directory', value: filePath };
        }
    }
    else if (sourceType === 'file') {
        if (op === 'added') {
            return { label: 'new file', value: filePath };
        }
        else if (op === 'removed') {
            return { label: 'removed file', value: filePath };
        }
        else if (op === 'changed') {
            return { label: 'modified file', value: filePath };
        }
    }
    throw new Error(`Unsupported source and op: ${sourceType}, ${op}`);
}
const PRETTY_CONTENT_ID = {
    'expoAutolinkingConfig:ios': 'Expo autolinking config (iOS)',
    'expoAutolinkingConfig:android': 'Expo autolinking config (Android)',
    'packageJson:scripts': 'package.json scripts',
    expoConfig: 'Expo config',
};
function printContentSource({ op, contentsBefore, contentsAfter, contentsId, }) {
    log_1.default.newLine();
    const prettyContentId = PRETTY_CONTENT_ID[contentsId] ?? contentsId;
    if (op === 'added') {
        log_1.default.log(`${chalk_1.default.dim('📝 New content')}: ${prettyContentId}`);
    }
    else if (op === 'removed') {
        log_1.default.log(`${chalk_1.default.dim('📝 Removed content')}: ${prettyContentId}`);
    }
    else if (op === 'changed') {
        log_1.default.log(`${chalk_1.default.dim('📝 Modified content')}: ${prettyContentId}`);
    }
    printContentsDiff(contentsBefore ?? '', contentsAfter ?? '');
}
function printContentsDiff(contents1, contents2) {
    const stringifiedContents1 = Buffer.isBuffer(contents1) ? contents1.toString() : contents1;
    const stringifiedContents2 = Buffer.isBuffer(contents2) ? contents2.toString() : contents2;
    const isStr1JSON = isJSON(stringifiedContents1);
    const isStr2JSON = isJSON(stringifiedContents2);
    const prettifiedContents1 = isStr1JSON
        ? JSON.stringify(JSON.parse(stringifiedContents1), null, 2)
        : stringifiedContents1;
    const prettifiedContents2 = isStr2JSON
        ? JSON.stringify(JSON.parse(stringifiedContents2), null, 2)
        : stringifiedContents2;
    (0, fingerprintDiff_1.abridgedDiff)(prettifiedContents1, prettifiedContents2, 0);
}
function isJSON(str) {
    try {
        JSON.parse(str);
        return true;
    }
    catch {
        return false;
    }
}
function appPlatformToPlatform(platform) {
    switch (platform) {
        case generated_1.AppPlatform.Android:
            return eas_build_job_1.Platform.ANDROID;
        case generated_1.AppPlatform.Ios:
            return eas_build_job_1.Platform.IOS;
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }
}
function appPlatformToString(platform) {
    switch (platform) {
        case generated_1.AppPlatform.Android:
            return 'android';
        case generated_1.AppPlatform.Ios:
            return 'ios';
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }
}
function stringToAppPlatform(platform) {
    switch (platform) {
        case 'android':
            return generated_1.AppPlatform.Android;
        case 'ios':
            return generated_1.AppPlatform.Ios;
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }
}
async function selectBuildToCompareAsync(graphqlClient, projectId, projectDisplayName, { filters, } = {}) {
    const spinner = (0, ora_1.ora)().start('Fetching builds…');
    let builds;
    try {
        builds = await (0, builds_1.fetchBuildsAsync)({ graphqlClient, projectId, filters });
        spinner.stop();
    }
    catch (error) {
        spinner.fail(`Something went wrong and we couldn't fetch the builds for the project ${projectDisplayName}.`);
        throw error;
    }
    if (builds.length === 0) {
        log_1.default.warn(`No fingerprints have been computed for builds of project ${projectDisplayName}.`);
        return null;
    }
    else {
        const build = await (0, prompts_1.selectAsync)('Which build do you want to compare?', builds.map(build => ({
            title: (0, builds_1.formatBuild)(build),
            value: build.id,
        })));
        return build;
    }
}
exports.selectBuildToCompareAsync = selectBuildToCompareAsync;
